---
title: Advanced Filters
description: Complex filter types including faceted, date range, and numeric filters.
---

# Advanced Filters

The DataTable supports an advanced filter mode where each filter instance includes an operator dropdown, allowing users to express precise conditions like "contains", "greater than", "is between", and more.

## Enabling Advanced Mode

Set `advancedMode` to `true` on the DataTable:

```vue
<DataTable
  :columns="columns"
  :data="data"
  :page-count="pageCount"
  :on-server-side-change="handleServerSideChange"
  :filter-fields="filterFields"
  :advanced-mode="true"
/>
```

The `advancedMode` prop is static -- it is set once at initialization and does not change at runtime.

## Simple Mode vs. Advanced Mode

| Feature                                       | Simple Mode                                       | Advanced Mode                                         |
| --------------------------------------------- | ------------------------------------------------- | ----------------------------------------------------- |
| Operator selection                            | No                                                | Yes (dropdown per filter)                             |
| Available filter types                        | All 8 types                                       | Base types only (text, number, date, select, boolean) |
| Multi-instance per field                      | Some types (text, number, date, range, daterange) | All types                                             |
| Filter value format                           | Natural per type                                  | Always `{ operator, value }` objects                  |
| Complex types (multiselect, range, daterange) | Available                                         | Not allowed (use operators instead)                   |

## Why Complex Types Are Not Allowed in Advanced Mode

In advanced mode, operators replace the need for complex filter types:

| Simple Mode Type | Advanced Mode Equivalent         |
| ---------------- | -------------------------------- |
| `multiselect`    | `select` with `isAnyOf` operator |
| `range`          | `number` with `between` operator |
| `daterange`      | `date` with `isBetween` operator |

If you accidentally use a complex type in advanced mode, the DataTable throws a clear error message explaining the migration:

```
[DataTable] Complex filter types (multiselect, range, daterange) are not allowed
in advanced mode. Use base types with operators instead:
  - multiselect -> select with defaultOperator: "isAnyOf"
  - range -> number with defaultOperator: "between"
  - daterange -> date with defaultOperator: "isBetween"
```

## Operators by Filter Type

### Text Operators

| Operator      | Label              | Description                                |
| ------------- | ------------------ | ------------------------------------------ |
| `contains`    | "contains"         | Case-insensitive substring match (default) |
| `equals`      | "equals"           | Exact match                                |
| `startsWith`  | "starts with"      | Value starts with input                    |
| `endsWith`    | "ends with"        | Value ends with input                      |
| `notContains` | "does not contain" | Inverse of contains                        |
| `notEquals`   | "not equals"       | Inverse of equals                          |
| `isEmpty`     | "is empty"         | No value (nullary -- no input needed)      |
| `isNotEmpty`  | "is not empty"     | Has value (nullary)                        |

### Number Operators

| Operator             | Label                         | Description                               |
| -------------------- | ----------------------------- | ----------------------------------------- |
| `equals`             | "equals"                      | Exact numeric match (default)             |
| `notEquals`          | "not equals"                  | Not equal to value                        |
| `greaterThan`        | "is greater than"             | Value > input                             |
| `greaterThanOrEqual` | "is greater than or equal to" | Value >= input                            |
| `lessThan`           | "is less than"                | Value < input                             |
| `lessThanOrEqual`    | "is less than or equal to"    | Value <= input                            |
| `between`            | "between"                     | Between two values (binary -- two inputs) |
| `isEmpty`            | "is empty"                    | No value (nullary)                        |
| `isNotEmpty`         | "is not empty"                | Has value (nullary)                       |

### Date Operators

| Operator     | Label          | Description                |
| ------------ | -------------- | -------------------------- |
| `is`         | "is"           | Exact date match (default) |
| `isBefore`   | "before"       | Date before input          |
| `isAfter`    | "after"        | Date after input           |
| `isBetween`  | "between"      | Between two dates (binary) |
| `isEmpty`    | "is empty"     | No value (nullary)         |
| `isNotEmpty` | "is not empty" | Has value (nullary)        |

### Select Operators

| Operator     | Label          | Description                                   |
| ------------ | -------------- | --------------------------------------------- |
| `is`         | "is"           | Equals single value (default)                 |
| `isAnyOf`    | "is any of"    | In array of values (array -- multi-select UI) |
| `isNot`      | "is not"       | Not equal to value                            |
| `isNoneOf`   | "is none of"   | Not in array of values (array)                |
| `isEmpty`    | "is empty"     | No value (nullary)                            |
| `isNotEmpty` | "is not empty" | Has value (nullary)                           |

### Boolean Operators

| Operator     | Label          | Description            |
| ------------ | -------------- | ---------------------- |
| `is`         | "is"           | Equals value (default) |
| `isEmpty`    | "is empty"     | No value (nullary)     |
| `isNotEmpty` | "is not empty" | Has value (nullary)    |

## Operator Categories

Operators fall into four categories that determine the filter UI:

| Category     | Operators               | Input UI                                    |
| ------------ | ----------------------- | ------------------------------------------- |
| **Standard** | Most operators          | Single value input                          |
| **Binary**   | `between`, `isBetween`  | Two value inputs (min/max or start/end)     |
| **Array**    | `isAnyOf`, `isNoneOf`   | Multi-select checkboxes                     |
| **Nullary**  | `isEmpty`, `isNotEmpty` | No input (operator is the entire condition) |

You can check operator categories programmatically:

```ts
import { isNullaryOperator, isBinaryOperator, isArrayOperator } from '@meldui/vue'

isNullaryOperator('isEmpty') // true
isBinaryOperator('between') // true
isArrayOperator('isAnyOf') // true
```

## Configuring Default and Available Operators

### Default Operator

Each filter type has a default operator. Override it per field:

```ts
const filterFields: DataTableFilterField<Employee>[] = [
  {
    id: 'name',
    label: 'Name',
    type: 'text',
    defaultOperator: 'startsWith', // instead of 'contains'
  },
  {
    id: 'salary',
    label: 'Salary',
    type: 'number',
    defaultOperator: 'greaterThan', // instead of 'equals'
  },
]
```

### Restricting Available Operators

Limit which operators appear in the dropdown:

```ts
const filterFields: DataTableFilterField<Employee>[] = [
  {
    id: 'name',
    label: 'Name',
    type: 'text',
    availableOperators: ['contains', 'equals', 'startsWith'],
    // Only these 3 operators will be shown (instead of all 8)
  },
  {
    id: 'salary',
    label: 'Salary',
    type: 'number',
    availableOperators: ['equals', 'greaterThan', 'lessThan', 'between'],
  },
]
```

## Advanced Mode Filter Value Format

In advanced mode, filter values are always arrays of `{ operator, value }` objects:

```ts
// Single filter instance
[{ operator: 'contains', value: 'john' }]

// Multiple filter instances for the same field
[
  { operator: 'contains', value: 'john' },
  { operator: 'startsWith', value: 'admin' },
]

// Binary operator (between)
[{ operator: 'between', value: [30000, 50000] }]

// Array operator (isAnyOf)
[{ operator: 'isAnyOf', value: ['active', 'pending'] }]

// Nullary operator (no value)
[{ operator: 'isEmpty', value: null }]
```

## Server-Side Params in Advanced Mode

When using `tableStateToServerParams`, advanced mode filter values are passed through as-is:

```ts
// Advanced mode server params
{
  filters: {
    name: [
      { operator: 'contains', value: 'john' },
      { operator: 'startsWith', value: 'admin' },
    ],
    salary: [
      { operator: 'between', value: [30000, 50000] },
    ],
    status: [
      { operator: 'isAnyOf', value: ['active', 'pending'] },
    ],
    isVerified: [
      { operator: 'is', value: true },
    ],
  }
}
```

Your server API needs to interpret the operator/value pairs and apply the appropriate query logic.

## Operator Utility Functions

MeldUI exports several functions for working with operators:

```ts
import {
  getAvailableOperators,
  getDefaultOperator,
  getOperatorLabel,
  isValidOperator,
  isNullaryOperator,
  isBinaryOperator,
  isArrayOperator,
} from '@meldui/vue'

// Get all operators for a type
getAvailableOperators('text', true)
// ['contains', 'equals', 'startsWith', 'endsWith', 'notContains', 'notEquals', 'isEmpty', 'isNotEmpty']

// Get the default operator
getDefaultOperator('number', true) // 'equals'

// Get human-readable label
getOperatorLabel('greaterThanOrEqual') // 'is greater than or equal to'

// Validate an operator for a type
isValidOperator('text', 'between', true) // false (between is for numbers)
isValidOperator('number', 'between', true) // true
```

## Custom Filter Plugins

For filter types beyond the built-in ones, use the plugin system to register custom filter components.

### Defining a Plugin

```ts
import { defineFilter } from '@meldui/vue'
import CurrencyFilter from './CurrencyFilter.vue'

const currencyFilter = defineFilter({
  type: 'currency',
  component: CurrencyFilter,
  operators: ['equals', 'greaterThan', 'lessThan', 'between'],
  defaultOperator: 'equals',
  supportsMultiInstance: true,
  serialize: (value) => ({
    amount: value.amount,
    currency: value.currency,
  }),
  deserialize: (raw) => ({
    amount: raw.amount,
    currency: raw.currency,
  }),
})
```

### FilterPlugin Interface

| Property                | Type                 | Description                                                               |
| ----------------------- | -------------------- | ------------------------------------------------------------------------- |
| `type`                  | `string`             | Unique identifier (must not conflict with built-in types)                 |
| `component`             | `Component`          | Vue component that renders the filter UI                                  |
| `operators`             | `FilterOperator[]`   | Available operators for this filter                                       |
| `defaultOperator`       | `FilterOperator`     | Default operator                                                          |
| `supportsMultiInstance` | `boolean`            | Allow multiple instances (default: `false` in simple, `true` in advanced) |
| `serialize`             | `(value) => unknown` | Transform value for server requests                                       |
| `deserialize`           | `(value) => TValue`  | Restore value from saved state                                            |

### Creating a Custom Filter Component

Your filter component receives `FilterPluginComponentProps` and must emit specific events:

```vue
<script setup lang="ts">
import type { FilterPluginComponentProps } from '@meldui/vue'

const props = defineProps<
  FilterPluginComponentProps & {
    currency?: string
    min?: number
    max?: number
  }
>()

const emit = defineEmits<{
  'value-change': [value: { amount: number; currency: string } | undefined]
  remove: []
  close: []
}>()
</script>
```

Required events:

| Event          | Payload              | Description                                                 |
| -------------- | -------------------- | ----------------------------------------------------------- |
| `value-change` | `value \| undefined` | Emitted when the filter value changes; `undefined` to clear |
| `remove`       | none                 | Emitted when the user removes the filter                    |
| `close`        | none                 | Emitted when the filter popover closes                      |

### Registering and Using Plugins

```vue
<DataTable
  :columns="columns"
  :data="data"
  :page-count="pageCount"
  :on-server-side-change="handleServerSideChange"
  :filter-plugins="[currencyFilter]"
  :filter-fields="[
    {
      id: 'price',
      label: 'Price',
      type: 'currency',
      currency: 'USD',
      min: 0,
      max: 10000,
    },
  ]"
/>
```

The `type` string in `filterFields` is matched against plugin `type` values. Any extra properties on the filter field definition (like `currency`, `min`, `max`) are passed through as props to the custom component via `v-bind`.

## Complete Advanced Filters Example

```vue
<script setup lang="ts">
import { ref } from 'vue'
import {
  DataTable,
  createColumnHelper,
  cellRenderers,
  tableStateToServerParams,
  serverResponseToTableData,
} from '@meldui/vue'
import type { DataTableFilterField } from '@meldui/vue'

interface Invoice {
  id: number
  customer: string
  amount: number
  status: 'draft' | 'sent' | 'paid' | 'overdue'
  isRecurring: boolean
  dueDate: string
}

const helper = createColumnHelper<Invoice>()

const columns = [
  helper.accessor('customer', { title: 'Customer' }),
  helper.accessor('amount', {
    title: 'Amount',
    cell: cellRenderers.currency({ currency: 'USD' }),
  }),
  helper.accessor('status', {
    title: 'Status',
    cell: cellRenderers.badge({
      variantMap: {
        draft: 'secondary',
        sent: 'outline',
        paid: 'default',
        overdue: 'destructive',
      },
    }),
  }),
  helper.accessor('isRecurring', {
    title: 'Recurring',
    cell: cellRenderers.boolean({ asBadge: true }),
  }),
  helper.accessor('dueDate', {
    title: 'Due Date',
    cell: cellRenderers.date({ format: 'medium' }),
  }),
]

// Advanced mode uses only base types (text, number, date, select, boolean)
const filterFields: DataTableFilterField<Invoice>[] = [
  {
    id: 'customer',
    label: 'Customer',
    type: 'text',
    placeholder: 'Filter customer...',
    availableOperators: ['contains', 'equals', 'startsWith', 'isEmpty'],
  },
  {
    id: 'amount',
    label: 'Amount',
    type: 'number',
    min: 0,
    step: 100,
    unit: 'USD',
    defaultOperator: 'greaterThan',
  },
  {
    id: 'status',
    label: 'Status',
    type: 'select',
    options: [
      { label: 'Draft', value: 'draft' },
      { label: 'Sent', value: 'sent' },
      { label: 'Paid', value: 'paid' },
      { label: 'Overdue', value: 'overdue' },
    ],
    defaultOperator: 'isAnyOf', // Replaces multiselect behavior
  },
  {
    id: 'isRecurring',
    label: 'Recurring',
    type: 'boolean',
  },
  {
    id: 'dueDate',
    label: 'Due Date',
    type: 'date',
    defaultOperator: 'isBetween', // Replaces daterange behavior
  },
]

const data = ref<Invoice[]>([])
const pageCount = ref(0)
const loading = ref(false)

async function handleServerSideChange({ sorting, filters, pagination }) {
  loading.value = true
  try {
    const params = tableStateToServerParams({ sorting, filters, pagination })
    const response = await fetch('/api/invoices', {
      method: 'POST',
      body: JSON.stringify(params),
    })
    const json = await response.json()
    const result = serverResponseToTableData(json)
    data.value = result.data
    pageCount.value = result.pageCount
  } finally {
    loading.value = false
  }
}
</script>

<template>
  <DataTable
    :columns="columns"
    :data="data"
    :page-count="pageCount"
    :on-server-side-change="handleServerSideChange"
    :filter-fields="filterFields"
    :advanced-mode="true"
    :loading="loading"
    search-column="customer"
    search-placeholder="Search invoices..."
  />
</template>
```
